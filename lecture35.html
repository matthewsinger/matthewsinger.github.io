<!doctype HTML>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"], 
                   ["\\[","\\]"], 
                   ["\\begin{equation}","\\end{equation}"], 
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true,
    ignoreClass: "tex2jax_ignore|JavaHighlightBlock|JavaHighlight"
  },
  "HTML-CSS": {
    availableFonts: [],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script src="codemirror.js"></script>
<script src="python.js"></script>
<script src="runmode.js"></script>
<script src="setup-page.js"></script>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 35: Dynamic Programming</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-style.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><link rel="stylesheet" type="text/css" href="extra-styles.css" title="default"/><link rel="stylesheet" type="text/css" href="codemirror.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="index.html" class="tocviewlink" data-pltdoc="x">Fundamentals II
<br/>
Introduction to Class-<wbr></wbr>based Program Design</a></td></tr></table></div><div class="tocviewsublisttop" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="Lectures.html" class="tocviewselflink" data-pltdoc="x">Lectures</a></td></tr><tr><td align="right"></td><td><a href="Lab_Materials.html" class="tocviewlink" data-pltdoc="x">Lab Materials</a></td></tr><tr><td align="right"></td><td><a href="Assignments.html" class="tocviewlink" data-pltdoc="x">Assignments</a></td></tr><tr><td align="right"></td><td><a href="Documentation.html" class="tocviewlink" data-pltdoc="x">Documentation</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_1&quot;);">&#9660;</a></td><td></td><td><a href="Lectures.html" class="tocviewlink" data-pltdoc="x">Lectures</a></td></tr></table><div class="tocviewsublist" style="display: block;" id="tocview_1"><table cellspacing="0" cellpadding="0"><tr><td align="right"></td><td><a href="lecture1.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Data Definitions in Java</a></td></tr><tr><td align="right"></td><td><a href="lecture2.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 2:</span> Data Definitions:<span class="mywbr"> &nbsp;</span> Unions</a></td></tr><tr><td align="right"></td><td><a href="lecture3.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 3:</span> Methods for simple classes</a></td></tr><tr><td align="right"></td><td><a href="lecture4.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Methods for unions</a></td></tr><tr><td align="right"></td><td><a href="lecture5.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 5:</span> Methods for self-<wbr></wbr>referential lists</a></td></tr><tr><td align="right"></td><td><a href="lecture6.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Accumulator methods</a></td></tr><tr><td align="right"></td><td><a href="lecture7.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Accumulator methods, continued</a></td></tr><tr><td align="right"></td><td><a href="lecture8.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Practice Design</a></td></tr><tr><td align="right"></td><td><a href="lecture9.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 9:</span> Abstract classes and inheritance</a></td></tr><tr><td align="right"></td><td><a href="lecture10.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 10:</span> Customizing constructors for correctness and convenience</a></td></tr><tr><td align="right"></td><td><a href="lecture11.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 11:</span> Defining sameness for complex data, part 1</a></td></tr><tr><td align="right"></td><td><a href="lecture12.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Defining sameness for complex data, part 2</a></td></tr><tr><td align="right"></td><td><a href="lecture13.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 13:</span> Abstracting over behavior</a></td></tr><tr><td align="right"></td><td><a href="lecture14.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Abstractions over more than one argument</a></td></tr><tr><td align="right"></td><td><a href="lecture15.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 15:</span> Abstracting over types</a></td></tr><tr><td align="right"></td><td><a href="lecture16.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Visitors</a></td></tr><tr><td align="right"></td><td><a href="lecture17.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 17:</span> Mutation</a></td></tr><tr><td align="right"></td><td><a href="lecture18.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 18:</span> Mutation inside structures</a></td></tr><tr><td align="right"></td><td><a href="lecture19.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 19:</span> Mutation, aliasing and testing</a></td></tr><tr><td align="right"></td><td><a href="lecture20.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 20:</span> Mutable data structures</a></td></tr><tr><td align="right"></td><td><a href="lecture21.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 21:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a></td></tr><tr><td align="right"></td><td><a href="lecture22.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 22:</span> Array<span class="mywbr"> &nbsp;</span>Lists</a></td></tr><tr><td align="right"></td><td><a href="lecture23.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 23:</span> For-<wbr></wbr>each loops and Counted-<wbr></wbr>for loops</a></td></tr><tr><td align="right"></td><td><a href="lecture24.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 24:</span> While loops</a></td></tr><tr><td align="right"></td><td><a href="lecture25.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 25:</span> Iterator and Iterable</a></td></tr><tr><td align="right"></td><td><a href="lecture26.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 26:</span> Hashing and Equality</a></td></tr><tr><td align="right"></td><td><a href="lecture27.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 27:</span> Introduction to Big-<span style="font-style: italic">O</span> Analysis</a></td></tr><tr><td align="right"></td><td><a href="lecture28.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 28:</span> Quicksort and Mergesort</a></td></tr><tr><td align="right"></td><td><a href="lecture29.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 29:</span> Priority Queues and Heapsort</a></td></tr><tr><td align="right"></td><td><a href="lecture30.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 30:</span> Breadth-<wbr></wbr>first search and Depth-<wbr></wbr>first search on graphs</a></td></tr><tr><td align="right"></td><td><a href="lecture31.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 31:</span> Dijkstra&rsquo;s Algorithm for single-<wbr></wbr>source shortest paths</a></td></tr><tr><td align="right"></td><td><a href="lecture32.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 32:</span> Minimum Spanning Trees</a></td></tr><tr><td align="right"></td><td><a href="Lectures.html#%28part._lec3345%29" class="tocviewlink" data-pltdoc="x">Lecture 33</a></td></tr><tr><td align="right"></td><td><a href="lecture34.html" class="tocviewlink" data-pltdoc="x"><span class="LectureNum">Lecture 34:</span> Implementing Objects</a></td></tr><tr><td align="right"></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 35:</span> Dynamic Programming</a></td></tr><tr><td align="right"></td><td><a href="Lectures.html#%28part._lec3533%29" class="tocviewlink" data-pltdoc="x">Lecture 36</a></td></tr></table></div></div><div class="tocviewlist"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_2&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 35:</span> Dynamic Programming</a></td></tr></table><div class="tocviewsublistbottom" style="display: none;" id="tocview_2"><table cellspacing="0" cellpadding="0"><tr><td align="right">35.1&nbsp;</td><td><a href="#%28part._seam-carving._.A_motivating_example__.Squeezing_pictures%29" class="tocviewlink" data-pltdoc="x">A motivating example:<span class="mywbr"> &nbsp;</span> Squeezing pictures</a></td></tr><tr><td align="right">35.2&nbsp;</td><td><a href="#%28part._fibonacci._.A_simple_example__.Fibonacci_numbers%29" class="tocviewlink" data-pltdoc="x">A simple example:<span class="mywbr"> &nbsp;</span> Fibonacci numbers</a></td></tr><tr><td align="right">35.3&nbsp;</td><td><a href="#%28part._knapsack._.Another_problem__.Savvy_shoppers%29" class="tocviewlink" data-pltdoc="x">Another problem:<span class="mywbr"> &nbsp;</span> Savvy shoppers</a></td></tr><tr><td align="right">35.4&nbsp;</td><td><a href="#%28part._recap._.Back_to_images%29" class="tocviewlink" data-pltdoc="x">Back to images</a></td></tr></table></div></div></div><div class="tocsub"><div class="tocsubtitle">On this page:</div><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber">35.1<tt>&nbsp;</tt></span><a href="#%28part._seam-carving._.A_motivating_example__.Squeezing_pictures%29" class="tocsubseclink" data-pltdoc="x">A motivating example:<span class="mywbr"> &nbsp;</span> Squeezing pictures</a></td></tr><tr><td><span class="tocsublinknumber">35.2<tt>&nbsp;</tt></span><a href="#%28part._fibonacci._.A_simple_example__.Fibonacci_numbers%29" class="tocsubseclink" data-pltdoc="x">A simple example:<span class="mywbr"> &nbsp;</span> Fibonacci numbers</a></td></tr><tr><td><span class="tocsublinknumber">35.2.1<tt>&nbsp;</tt></span><a href="#%28part._fibonacci._.Step_0__.Naive_recursive_solution%29" class="tocsubseclink" data-pltdoc="x">Step 0:<span class="mywbr"> &nbsp;</span> Naive recursive solution</a></td></tr><tr><td><span class="tocsublinknumber">35.2.2<tt>&nbsp;</tt></span><a href="#%28part._fibonacci._.Improvement_1__memoization%29" class="tocsubseclink" data-pltdoc="x">Improvement 1:<span class="mywbr"> &nbsp;</span> memoization</a></td></tr><tr><td><span class="tocsublinknumber">35.2.3<tt>&nbsp;</tt></span><a href="#%28part._fibonacci._.Improvement_2__.Iterative_vs_recursive_solutions%29" class="tocsubseclink" data-pltdoc="x">Improvement 2:<span class="mywbr"> &nbsp;</span> Iterative vs recursive solutions</a></td></tr><tr><td><span class="tocsublinknumber">35.2.4<tt>&nbsp;</tt></span><a href="#%28part._fibonacci._.Improvement_3__.Eliminating_some_bookeeping%29" class="tocsubseclink" data-pltdoc="x">Improvement 3:<span class="mywbr"> &nbsp;</span> Eliminating some bookeeping</a></td></tr><tr><td><span class="tocsublinknumber">35.2.5<tt>&nbsp;</tt></span><a href="#%28part._fibonacci._.Strategy_.Recap%29" class="tocsubseclink" data-pltdoc="x">Strategy Recap</a></td></tr><tr><td><span class="tocsublinknumber">35.3<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Another_problem__.Savvy_shoppers%29" class="tocsubseclink" data-pltdoc="x">Another problem:<span class="mywbr"> &nbsp;</span> Savvy shoppers</a></td></tr><tr><td><span class="tocsublinknumber">35.3.1<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Step_0__.Naive_recursive_solution%29" class="tocsubseclink" data-pltdoc="x">Step 0:<span class="mywbr"> &nbsp;</span> Naive recursive solution</a></td></tr><tr><td><span class="tocsublinknumber">35.3.2<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Improvement_1__.Memoization%29" class="tocsubseclink" data-pltdoc="x">Improvement 1:<span class="mywbr"> &nbsp;</span> Memoization</a></td></tr><tr><td><span class="tocsublinknumber">35.3.3<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Improvement_2__.Interative_solution%29" class="tocsubseclink" data-pltdoc="x">Improvement 2:<span class="mywbr"> &nbsp;</span> Interative solution</a></td></tr><tr><td><span class="tocsublinknumber">35.3.4<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Improvement_3__.Less_space_%29" class="tocsubseclink" data-pltdoc="x">Improvement 3:<span class="mywbr"> &nbsp;</span> Less space?</a></td></tr><tr><td><span class="tocsublinknumber">35.3.5<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Enhancement__reading_out_the_solution%29" class="tocsubseclink" data-pltdoc="x">Enhancement:<span class="mywbr"> &nbsp;</span> reading out the solution</a></td></tr><tr><td><span class="tocsublinknumber">35.3.6<tt>&nbsp;</tt></span><a href="#%28part._knapsack._.Strategy_.Recap%29" class="tocsubseclink" data-pltdoc="x">Strategy Recap</a></td></tr><tr><td><span class="tocsublinknumber">35.4<tt>&nbsp;</tt></span><a href="#%28part._recap._.Back_to_images%29" class="tocsubseclink" data-pltdoc="x">Back to images</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="version">7.3</span></div><div class="navsettop"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture34.html" title="backward to &quot;Lecture 34: Implementing Objects&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Lectures.html#%28part._lec3533%29" title="forward to &quot;Lecture review-2&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div><h4><a name="(part._)"></a><span class="LectureNum">Lecture 35:</span> Dynamic Programming</h4><p class="boxed">Using data to avoid redundant computation</p><h5>35.1<tt>&nbsp;</tt><a name="(part._seam-carving._.A_motivating_example__.Squeezing_pictures)"></a>A motivating example: Squeezing pictures</h5><p>In Assignment A-squeezing, you will be working on a fairly sophisticated algorithm to
&ldquo;squeeze&rdquo; images to fit into a smaller region, without sacrificing any of
the &ldquo;interesting&rdquo; regions of the image.  Intuitively, our goal is to find
some connected path from one side of the image to the opposite side, such that
that path is as &ldquo;boring&rdquo; as possible, and remove those pixels.  We can define
&ldquo;boring&rdquo; in a number of ways, but for now let&rsquo;s just assume that a pixel is
interesting if it is different enough in brightness from its neighbors.  That
way, stripes or rapidly changing areas of color will be interesting &#8212;<wbr></wbr>
removing even a single pixel might remove a stripe &#8212;<wbr></wbr> while gradual smooth
areas are boring &#8212;<wbr></wbr> removing one pixel won&rsquo;t make much of a difference.</p><p>In order to ensure that we remove pixels in a sensible way, we need to remove a
<span style="font-style: italic">connected</span> path from one side of the image to another.  A path is
connected if every pixel is adjacent to or diagonally adjacent to the next
pixel.  But how can we compute the &ldquo;most boring path&rdquo; efficiently?  Think for
a moment about a vertical path, that ends at the middle pixel of the bottom
row.</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_38.png" alt="image" width="239.8515625" height="128.3984375"/></p><p>How might we have gotten there?  Well, the previous pixel in the path
could have been any of the three pixels directly above it.</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_39.png" alt="image" width="239.8515625" height="128.3984375"/></p><p>How might we have gotten to any of <span style="font-style: italic">them</span>?  Each of them has three pixels
above them, for a total of nine; each of those nine have three pixels above
them, etc. &#8212;<wbr></wbr> the number of paths seems to be \(3^{image~height}\), which
is quite expensive!</p><p>But is it really that bad?  Looking more carefully at the paths:</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_40.png" alt="image" width="239.8515625" height="128.3984375"/></p><p>There appears to be a great deal of overlap between the paths.  There are three
different ways to get from <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_41.png" alt="image" width="19.734375" height="20.1328125"/> to <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_42.png" alt="image" width="20.21484375" height="20.1328125"/>; there are two
ways to get to <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_43.png" alt="image" width="20.21484375" height="20.1328125"/>; etc.  Consider the &ldquo;most boring&rdquo; path to
<img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_44.png" alt="image" width="19.734375" height="20.1328125"/>, and suppose it goes through <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_45.png" alt="image" width="21.140625" height="20.1328125"/>.  Critically, the
<span style="font-style: italic">most</span> boring path must include the most boring way to get to
<img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_46.png" alt="image" width="21.140625" height="20.1328125"/> &ndash; or else we could find an even more boring path to get to
<img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_47.png" alt="image" width="19.734375" height="20.1328125"/>.  But to compute the most boring path to <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_48.png" alt="image" width="21.140625" height="20.1328125"/>, we must
compute the most boring path to <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_49.png" alt="image" width="20.21484375" height="20.1328125"/>.  So <span style="font-style: italic">why bother recomputing
that again</span> when we try to compute the most boring path to <img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_50.png" alt="image" width="21.140625" height="20.1328125"/> or
<img style="vertical-align: -2.53125px; margin: -3px -3px -3px -3px;" src="pict_51.png" alt="image" width="21.140625" height="20.1328125"/>?  Wouldn&rsquo;t it be better to compute that answer once and for all,
and <span style="font-style: italic">reuse</span> that answer as needed?</p><p>In fact, this sort of problem comes up quite often, and there are some powerful
techniques to solve them.  When the problem has the following hallmarks:</p><ul><li><p>The problem can be solved recursively</p></li><li><p>There are lots of subproblems to be solved</p></li><li><p>The <span style="font-style: italic">same</span> subproblems show up as part of <span style="font-style: italic">several</span> other
subproblems</p></li></ul><p>we can likely find a solution that runs much faster than the simple recursive
one, if we&rsquo;re a bit clever about it.  This technique is known as <span style="font-style: italic">dynamic
programming</span> (though it has nothing to do with &ldquo;dynamic&rdquo; dispatch or
&ldquo;progamming&rdquo; as we refer to it).  Let&rsquo;s start with a simple example, and
work our way back up to the original problem.</p><h5>35.2<tt>&nbsp;</tt><a name="(part._fibonacci._.A_simple_example__.Fibonacci_numbers)"></a>A simple example: Fibonacci numbers</h5><h5>35.2.1<tt>&nbsp;</tt><a name="(part._fibonacci._.Step_0__.Naive_recursive_solution)"></a>Step 0: Naive recursive solution</h5><p>We&rsquo;ve seen the computation for Fibonacci numbers several times before:</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">2</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">What is the runtime of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="RktMeta"></span></span></span>, as a big-\(O\) function of
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span>?</div></p></blockquote><p>When <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span> is small, the function takes constant time.  But to see how long
it takes for larger <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span>, we should draw out the call tree, and see how
many calls are made:</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_52.png" alt="image" width="680.953125" height="133.1953125"/></p><p>Looking at a larger tree (where we only draw the argument \(n\), for brevity):</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_53.png" alt="image" width="453.685546875" height="175.59375"/></p><p>It&rsquo;s pretty clear in this case that the longest path in the tree is the
leftmost one and is as tall as \(n\), and the shortest path is the rightmost
one and is as tall as \(n/2\).</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Why?</div></p></blockquote><p>Crucially, this tells us the number of nodes of the tree!  Since the shortest
path is \(n/2\), and every other path is longer than that, we know that the
tree is <span style="font-style: italic">full</span> to depth \(n/2\), which means it contains at least
\(2^{n/2}\) nodes.  Further, since it&rsquo;s at most \(n\) nodes tall, it
contains at most \(2^n\) nodes.  Therefore, the tree is \(O(2^n)\)
elements big.</p><p>(We can actually be a bit more precise.  The lower bound of \(2^{n/2}\)
equals \((2^{1/2})^n = \sqrt{2}^n \sim 1.4142^n\)  The upper bound is
\(2^n\).  A careful analysis will show that the exact quantity is
\(\phi^n \sim 1.516 ^ n\), where \(\phi = (1 + \sqrt 5)/2\) is the golden
ratio.  It&rsquo;s nice to see that the exact value really does fall between our
lower and upper bounds!)</p><h5>35.2.2<tt>&nbsp;</tt><a name="(part._fibonacci._.Improvement_1__memoization)"></a>Improvement 1: memoization</h5><p><div class="SIntrapara"><blockquote class="refpara"><blockquote class="refcolumn"><blockquote class="refcontent"><p>Relative to <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span>, how many times do we compute
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> while computing <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, for any particular <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">i</span><span class="RktMeta"></span></span></span>?</p></blockquote></blockquote></blockquote></div><div class="SIntrapara">But there&rsquo;s a <span style="font-style: italic">lot</span> of redundancy in this computation!  We compute
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">6</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> twice, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">5</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> three times, <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">4</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> five times... why
bother?  We&rsquo;ve seen solutions to this in the past: we collect an
<span style="font-style: italic">accumulator</span>, and this time we&rsquo;ll fill it with all the answers we&rsquo;ve
computed already, and then we don&rsquo;t need to recompute them.  Here&rsquo;s the code
for that:</div></p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">fibAcc</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// Base cases: fib(0) = 1
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">fibAcc</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// fib(1) = 1
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">fibAcc</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fibAcc</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Check for redundant computation
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Compute the new things:
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">ans</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">2</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">fib</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">ans</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">ans</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>When used in this way, we refer to this sort of accumulator as a <span style="font-style: italic">memo
table</span>: it lets us &ldquo;take notes&rdquo; about subproblems we&rsquo;ve already seen.  We
refer to the entire technique as <span style="font-style: italic">memoization</span> of an existing function.</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Why do you think the memo table for <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="RktMeta"></span></span></span> was an
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="RktMeta"></span></span></span>?  Is there anything about the signature for
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="RktMeta"></span></span></span> that would suggest so?</div></p></blockquote><p>Now, how many times do we call <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fibAcc</span><span class="RktMeta"></span></span></span> for a given <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span>?  As we
evaluate the call tree above, as we go down the leftmost path, we&rsquo;re constantly
encountering new subproblems, so we must evaluate each call at least once.  But
<span style="font-style: italic">for every other call</span>, we&rsquo;ll already have computed the answer, so we&rsquo;ll
skip all the recursive calls!</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_54.png" alt="image" width="199.8515625" height="198.9375"/></p><p>Now, we only ever call <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">fib</span><span class="RktMeta"></span></span></span> with each value of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span> at most twice, so
our runtime is now <span style="font-style: italic">linear</span>.  Quite an improvement from \(O(2^n)\)!
Though it did come at some cost: we&rsquo;re now using \(O(n)\) space to store the
intermediate results.</p><h5>35.2.3<tt>&nbsp;</tt><a name="(part._fibonacci._.Improvement_2__.Iterative_vs_recursive_solutions)"></a>Improvement 2: Iterative vs recursive solutions</h5><p>Looking carefully at our code, we see that we recursively fill in the table of
answers, such that the second time we need a given answer, it&rsquo;s waiting for
us.  But the recursive structure of the code doesn&rsquo;t match the order in which
we fill in the table.  We&rsquo;re calling functions in a &ldquo;top-down&rdquo; order (from
bigger values of <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">n</span><span class="RktMeta"></span></span></span> to smaller ones), but we&rsquo;re filling in the table in
the other order.  Can we revise our code to match that filling-in order?</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Try this.</div></p></blockquote><p>Here is one possible answer:</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">2</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">2</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">answers</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>Without too much trouble, we see that we can fill in the table &ldquo;bottom-up&rdquo;,
from low indices to higher ones.  Note that this solution <span style="font-style: italic">looks almost
nothing like</span> our previous recursive one, and there&rsquo;s very little in the
problem that would suggest this as a solution.  We arrived at this approach by
considering the <span style="font-style: italic">bookkeeping</span> in the previous memoized solution.</p><h5>35.2.4<tt>&nbsp;</tt><a name="(part._fibonacci._.Improvement_3__.Eliminating_some_bookeeping)"></a>Improvement 3: Eliminating some bookeeping</h5><p>Now that we have an iterative, table-based solution, we can make one final
observation: we don&rsquo;t need most of the table!  Indeed, once we&rsquo;ve computed
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">answers</span><span class="RktMeta"></span></span></span> at index \(i\), we never need to access indices \(i - 2\)
or lower.  So we could arrive at our fourth and final design for this function:</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">fib</span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">n</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">==</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">prev</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cur</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">2</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">2</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">n</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">i</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">prev</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cur</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">prev</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cur</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">cur</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">next</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">cur</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><p>We now have a solution that takes \(O(n)\) time and \(O(1)\) space, which
is pretty clearly optimal.</p><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Actually, for this particular problem, there exists a closed-form
formula to compute the answer directly: \(fib(n) = (\phi^n -
(1-\phi)^{-n})/\sqrt 5\).  But this appears to take \(O(n)\) multiplications,
so it&rsquo;s no faster than our iterative solution above...  Can you implement a
solution that computes the answer in \(O(log n)\) multiplications?  Is that
better or worse, in practice?  (Hint: <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">double</span><span class="RktMeta"></span></span></span>s...)</div></p></blockquote><h5>35.2.5<tt>&nbsp;</tt><a name="(part._fibonacci._.Strategy_.Recap)"></a>Strategy Recap</h5><p>Our initial problem had a nice, straightforward recursive solution that was
woefully inefficient.  In particular, we noticed that it was repetitively
computing the same subproblems many, many times.  So we decided to memoize the
function, by adding an accumulator parameter that would store all the
sub-answers we encountered in the recursion, and eliminate the need to compute
them again.</p><p>At this point, our algorithm ran much faster.  And in many cases, in practice,
you could probably stop here!  But, it is possible to do better: if we shift
our attention from the recursive structure of the problem to the filling-in
structure of the accumulator, we see that our code isn&rsquo;t organized correctly.
We can therefore revise our code to fill in the table in a systematic order,
using loops and iteration rather than recursion, and thereby get a more obvious
performance bound for our new code.</p><p>Lastly, we might get lucky and notice that some of our accumulated state is
only needed for a little while, and that as we progress through our loop, we
can &ldquo;forget&rdquo; some earlier results.  This may lead to one last performance
boost for our algorithm, such that it uses far less space than we initially may
have expected.</p><h5>35.3<tt>&nbsp;</tt><a name="(part._knapsack._.Another_problem__.Savvy_shoppers)"></a>Another problem: Savvy shoppers</h5><p>Suppose you&rsquo;re a contestant on a shopping-spree gameshow, where there are only
a few rules:</p><ul><li><p>Each item has a cost (in dollars) and a score (in points)</p></li><li><p>You may only buy at most one of each item</p></li><li><p>You have a budget of some number of dollars</p></li></ul><p>Your goal is to fill a shopping cart with items that maximize your score while
staying under budget &ndash; if you go over budget, you automatically lose.</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">How do you win?</div></p></blockquote><h5>35.3.1<tt>&nbsp;</tt><a name="(part._knapsack._.Step_0__.Naive_recursive_solution)"></a>Step 0: Naive recursive solution</h5><p>Actually, merely coming up with a recursive solution isn&rsquo;t so trivial this
time!  Our goal is to find a way to break the problem down into subproblems
that &ldquo;repeat&rdquo; somehow, so that we can reuse answers along the way.  At first,
we might try a divide-and-conquer approach, and think that we could split the
items into two groups, divide our budget in half among them, and pick the best
shopping carts for the two halves: surely the combination of those two best
halves should give a best total cart?</p><p>Unfortunately not: there&rsquo;s no obvious way to split the budget between the two
groups of items.  For example, suppose there were only two items:  Item A costs
\$10 and is worth 50 points, and item B costs \$1 and is worth 1 point.  If our
budget is \$10, then if we split the budget <span style="font-style: italic">at all</span>, we will only be able
to buy Item B, and we&rsquo;ll lose.  (In general, constructing &ldquo;extreme&rdquo; edge-case
examples like this is a good strategy towards breaking any &ldquo;obvious&rdquo;
solutions.)</p><p>However, let&rsquo;s consider what decisions we get to make during this problem.  For
each item, we can choose whether to purchase it or not.  Let&rsquo;s examine the two
possibilities:</p><ul><li><p>If we purchase item \(i\), we have gained \(score(i)\) points, and we&rsquo;ve
spend \(cost(i)\) dollars of our budget.</p></li><li><p>If we skip item \(i\), we have gained zero points, but we still have
all of our budget.</p></li></ul><p>This suggests a possible strategy: we&rsquo;ll recur through the list of each of our
items, and we&rsquo;ll choose the maximum of either purchasing the current item or
skipping it:</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScore</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScoreHelp</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScoreHelp</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Base case: no more items
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&gt;=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjComment">// Recursive case: take the better of...
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Math</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">max</span><span class="ProfjKeyword">(</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// Try buying this item
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScoreHelp</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                                               </span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                                               </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// Skip buying this item
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">bestScoreHelp</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><h5>35.3.2<tt>&nbsp;</tt><a name="(part._knapsack._.Improvement_1__.Memoization)"></a>Improvement 1: Memoization</h5><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Add a memo-table to the solution above.  What should its type be?
How can you tell?</div></p></blockquote><p>Since there are two arguments that change during our recursive calls, we need a
2-dimensional (i.e. nested) <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>.  Since our function returns an
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="RktMeta"></span></span></span>, our table should be an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;&gt;</span><span class="RktMeta"></span></span></span>.  We
need to choose a meaning for the indices of this array, though: let&rsquo;s
arbitrarily choose that the outer index means <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">curItemIndex</span><span class="RktMeta"></span></span></span> and the inner
index means <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">remainingBudget</span><span class="RktMeta"></span></span></span>, just to match our parameter order in our function.</p><div class="JavaHighlightBlock"><blockquote class="SCodeFlow"><table cellspacing="0" cellpadding="0" class="RktBlk"><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScore</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">memos</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// It's a bit easier to pre-fill the array with placeholders,
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// than to try to dynamicalaly fill it during the algorithm itself.
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">idx</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">idx</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">idx</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">vals</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">new</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">for</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">b</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">b</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&lt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">b</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">vals</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjType">Integer</span><span class="ProfjDefault">.</span><span class="ProfjConstant">MAX_VALUE</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjComment">// Placeholder value to mark invalid answers
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">add</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">vals</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjIdentifier">bestScoreMemo</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScoreMemo</span><span class="ProfjKeyword">(</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                  </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Integer</span><span class="ProfjKeyword">&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                  </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Lookup memoized answer:
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">!=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Integer</span><span class="ProfjDefault">.</span><span class="ProfjConstant">MAX_VALUE</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjComment">// Base case: no more items
</span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">if</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">&gt;=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">size</span><span class="ProfjKeyword">(</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">0</span><span class="ProfjDefault">;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">else</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">{</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjComment">// Recursive case: take the better of...
</span><span class="ProfjWhiteSpace">    </span><span class="ProfjPrimType">int</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">ans</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">=</span><span class="ProfjWhiteSpace"> </span><span class="ProfjType">Math</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">max</span><span class="ProfjKeyword">(</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// Try buying this item
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">bestScoreAcc</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                                              </span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">                                              </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">,</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjComment">// Skip buying this item
</span><span class="ProfjWhiteSpace">      </span><span class="ProfjIdentifier">bestScoreAcc</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjLiteral">1</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">      </span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">curItemIndex</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">set</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">remainingBudget</span><span class="ProfjDefault">,</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">ans</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">    </span><span class="ProfjKeyword">return</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">ans</span><span class="ProfjDefault">;</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjWhiteSpace">  </span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr><tr><td><span class="RktMeta"></span><span class="ProfjKeyword">}</span><span class="RktMeta"></span></td></tr></table></blockquote></div><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Why is the final answer found at <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>?
What in the original code tells you so?</div></p></blockquote><h5>35.3.3<tt>&nbsp;</tt><a name="(part._knapsack._.Improvement_2__.Interative_solution)"></a>Improvement 2: Interative solution</h5><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Revise the code above to fill in the table, in order using loops
rather than recursively.</div></p></blockquote><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">How much time does this new solution take, as a big-\(O\)
function?  What are the relevant arguments?</div></p></blockquote><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">How much time does the memoized version take?  Is it the same, or
smaller?  Why?</div></p></blockquote><h5>35.3.4<tt>&nbsp;</tt><a name="(part._knapsack._.Improvement_3__.Less_space_)"></a>Improvement 3: Less space?</h5><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Can you &ldquo;play the same trick&rdquo; as we did for Fibonacci numbers, and
eliminate some of the storage?  Why or why not?</div></p></blockquote><h5>35.3.5<tt>&nbsp;</tt><a name="(part._knapsack._.Enhancement__reading_out_the_solution)"></a>Enhancement: reading out the solution</h5><p>We may want to know more than just &ldquo;what is the maximum score we can
achieve?&rdquo;  We might want to also know &ldquo;which items do we need to buy to get
that score?&rdquo;  How might we do that?  The simplest approach seems to be just
build a second accumulator, an <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">ArrayList</span><span class="ProfjKeyword">&lt;</span><span class="ProfjType">Boolean</span><span class="ProfjKeyword">&gt;&gt;</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">decisions</span><span class="RktMeta"></span></span></span>,
whose interpretation is, &ldquo;for a given item index and budget, should we buy
this item or not?&rdquo;  We can update this table in our recursive case, so that it
essentially tells us which of the two scores was chosen as maximum.</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Will that be enough to read out the entire solution?</div></p></blockquote><p>We know that our maximum score shows up in <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">memos</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>.  So
if we look in <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">decisions</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, we&rsquo;ll see whether we
purchased item 0 or not.  If we skipped it, then we know our next purchase
decision can be found at <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">decisions</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>.  If we bought it,
then our next purchase decision can be found at
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">decisions</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>.  Looking at that boolean
will tell us whether we should purchase item 1 or not, and we can work our way
back through the table as needed.</p><p>Do we really need this extra table, though?  Can we do better?</p><blockquote class="IncerciseBody"><p><div class="SIntrapara"><p class="Incercise">Do Now!</p></div><div class="SIntrapara">Try to eliminate this extra <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">decisions</span><span class="RktMeta"></span></span></span> table.  Is there
another way to deduce what the correct purchase decisions were?</div></p></blockquote><p>Since we know that <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">decisions</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">0</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> must either equal
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">decisions</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span> or equal
<span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">scores</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">+</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">decisions</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjIdentifier">budget</span><span class="ProfjWhiteSpace"> </span><span class="ProfjKeyword">-</span><span class="ProfjWhiteSpace"> </span><span class="ProfjIdentifier">costs</span><span class="ProfjDefault">.</span><span class="ProfjIdentifier">get</span><span class="ProfjKeyword">(</span><span class="ProfjLiteral">1</span><span class="ProfjKeyword">)</span><span class="ProfjKeyword">)</span><span class="RktMeta"></span></span></span>, why not just
look at those two values?  If we equal the first one, then we must not have
purchased item 0; if we equal the second, then we must indeed have purchased
it.  (And if they&rsquo;re tied, then it didn&rsquo;t matter!)</p><p>So our memo table contains all the information we need to reconstruct not just
the value of the final solution, but also which items go into making it.  Not a
bad deal!</p><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Once again, can you eliminate some of the storage requirements of
this algorithm?  (If your answer has changed from above, why?  If it&rsquo;s the
same, why?)</div></p></blockquote><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Open-ended: now that we&rsquo;re looking at <span style="font-style: italic">which</span> items go into our
solution, we might also want to ask, &ldquo;how <span style="font-style: italic">many</span> solutions are there of
maximum value?&rdquo;  The memo table we&rsquo;ve constructed should already have enough
information for you.  Design a function <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjIdentifier">countSolutions</span><span class="RktMeta"></span></span></span> that takes the
memo table (and the costs and scores lists) and computes how many solutions
there are.  What is the worst-case number of solutions, and what example costs
and scores could you set up to force that scenario?</div></p></blockquote><h5>35.3.6<tt>&nbsp;</tt><a name="(part._knapsack._.Strategy_.Recap)"></a>Strategy Recap</h5><p>This problem is known formally as the
<a href="https://en.wikipedia.org/wiki/Knapsack_problem#0/1_knapsack_problem">0-1
Knapsack Problem</a>.  We say that this algorithm runs in <span style="font-style: italic">pseudo-polynomial
time</span>, because it runs in time proportional to the budget.  But we can
represent really big numbers using really few digits &#8212;<wbr></wbr> that&rsquo;s the whole point
of a place-value system of numbers! &#8212;<wbr></wbr> so relative to the <span style="font-style: italic">size</span> of the
budget (in bits), rather than the magnitude of the budget (i.e. its absolute
value), we run in exponential time.  Still, that&rsquo;s an improvement over the
naive algorithm, which ran in exponential time relative to the number of items,
as well!</p><h5>35.4<tt>&nbsp;</tt><a name="(part._recap._.Back_to_images)"></a>Back to images</h5><p>The motivating example at the start of this lecture is, in hindsight, clearly
calling for a dynamic programming solution.  In the homework, we will give you
the suggested solution for how to structure the table you&rsquo;re building (though
it won&rsquo;t be a nested <span class="RktBlk"><span class="JavaHighlight"><span class="RktMeta"></span><span class="ProfjType">ArrayList</span><span class="RktMeta"></span></span></span>, per se), and we&rsquo;ll show you how to read
out the solution that you&rsquo;ve computed.  (Not all dynamic programs compute
atomic data as answers!)  As you work through that problem, try thinking
through the four-step process above, and see if you can figure out which step
corresponds best to the structure you&rsquo;re working with in the assignnment.</p><blockquote class="ExerciseBody"><p><div class="SIntrapara"><p class="Exercise">Exercise</p></div><div class="SIntrapara">Can you &ldquo;work backwards&rdquo; from whichever step you&rsquo;re at in the
assignment, backwards towards the naive recursive solution?</div></p></blockquote><div class="navsetbottom"><span class="navleft"><div class="nosearchform"></div>&nbsp;&nbsp;</span><span class="navright">&nbsp;&nbsp;<a href="lecture34.html" title="backward to &quot;Lecture 34: Implementing Objects&quot;" data-pltdoc="x">&larr; prev</a>&nbsp;&nbsp;<a href="Lectures.html" title="up to &quot;Lectures&quot;" data-pltdoc="x">up</a>&nbsp;&nbsp;<a href="Lectures.html#%28part._lec3533%29" title="forward to &quot;Lecture review-2&quot;" data-pltdoc="x">next &rarr;</a></span>&nbsp;</div></div></div><div id="contextindicator">&nbsp;</div></body></html>